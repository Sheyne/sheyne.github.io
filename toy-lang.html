<style>
.args {
	border-radius: 0.5em;
	border: 1px solid black;
	border-width: 0px 1px;
	padding: 0em 0.5em;
}

.dead-result {
	background: rgba(255, 0, 0, 0.15);
	border: 1px solid red;
	margin: -1px;
}

.children-selected table {
	background-color: red;
}

.horiz-component:not(:last-child) > table > tr:last-child::after  {
	content: ",";
	vertical-align: middle;
	display: table-cell;
}

#cursor {
	display: inline-block;
    height: 0.7em;
    padding: 0.3em 0.1em 0.3em 0.1em;
    margin: -0.3em -0.1em -0.3em -0.1em;
    background: rgba(0,0,0,0.5);
}

table {
	padding: 1px;
	border-spacing: 0px;
}

</style>

<div id="container">
</div>

<div>
How to use: navigate with the mouse or arrow keys (up and down move between arguments). "Enter" enters edit mode. "Esc" exits edit mode. 
Type to rename things. Vertical elements in parens are function arguments. </div>

<div>The default example above computes the summation from for <code>i = low</code> to <code>i = high</code> of <code>func(i)</code>.</div>
<div id="code"></div>

<script>

function plus(args, context, results) {
	var res = 0;
	for (var e of args) {
		var v = evalnumber(e, context, results, "add");
		if (v instanceof DeadResult) {
			return v;
		}
		res += v;
	}
	return res;
}

function evalnumber(e, context, results, message) {
	var v = evallisp(e, context, results);
	if (v instanceof DeadResult) {
		return v;
	}
	if (typeof(v) !== "number") {
		return new DeadResult("can only " + message + " numbers");
	}
	return v;
}

function lessthan(args, context, results) {
	return binaryMath(function(a, b) {
		return a < b
	}, args, context, results, "<");
}

lessthan.numArgs = 2;

function greaterthan(args, context, results) {
	return binaryMath(function(a, b) {
		return a > b
	}, args, context, results, ">");
}

greaterthan.numArgs = 2;

function equalto(args, context, results) {
	return binaryMath(function(a, b) {
		return a === b
	}, args, context, results, "=");
}

equalto.numArgs = 2;

function minus(args, context, results) {
	return binaryMath(function(a, b) {
		return a - b
	}, args, context, results, "-");
}

minus.numArgs = 2;

function divide(args, context, results) {
	return binaryMath(function(a, b) {
		return a / b
	}, args, context, results, "/");
}

divide.numArgs = 2;

function binaryMath(op, args, context, results, name) {
	var res = 0;
	if (args.length != 2) {
		return new DeadResult(name + " needs exactly two arguments");
	}
	var a = evalnumber(args[0], context, results, name), b = evalnumber(args[1], context, results, name);
	if (a instanceof DeadResult) {
		return a;
	}
	if (b instanceof DeadResult) {
		return b;
	}
	return op(a, b);
}

function times(args, context, results) {
	var res = 1;
	for (var e of args) {
		var v = evalnumber(e, context, results, "multiply");
		if (v instanceof DeadResult) {
			return v;
		}
		res *= v;
	}
	return res;
}

function iff(args, context, results) {
	var v = evallisp(args[0], context, results);
	if (v instanceof DeadResult) {
		return v;
	}
	if (v !== true && v !== false) {
		return new DeadResult("argument to if must be boolean");
	}
	if (v) {
		return evallisp(args[1], context, results);
	} else {
		return evallisp(args[2], context, results);
	}
}

iff.numArgs = 3;

function letrec(args, context, results) {
	var newContext = {
		parentContext: context,
	}
	for (var arg of args.slice(0, args.length - 1)) {
		if (! arg.args) {
			return new DeadResult("binding '" + arg.name + "' must have a body");
		}
		newContext[arg.name] = evallisp(arg.args[0], newContext, results);
	}
	return evallisp(args[args.length - 1], newContext, results);
}

function lambda(outerArgs, outerContext, results) {
	var argNames = [];
	for (var name of outerArgs[0].args) {
		argNames.push(name.name);
	}

	var lambdaFunc = function (args, context, results) {
		var newContext = {parentContext: context};
		for (var i = 0; i < argNames.length; i ++) {
			newContext[argNames[i]] = evallisp(args[i], context, results);
		}
		return evallisp(outerArgs[1], newContext, results);
	};

	lambdaFunc.numArgs = argNames.length;

	return lambdaFunc;
}

lambda.numArgs = 2;

function calllisp(func, args, context, results) {
	if (func instanceof DeadResult) {
		return func;
	} else if (typeof(func) !== "function")  {
		return new DeadResult("calling a non-function");
	} else if (func.numArgs && func.numArgs != args.length) {
		return new DeadResult("arity error");
	} else {
		return func(args, context, results);		
	}
}

function evalf(args, context, results) {
	var func = evallisp(args[0], context, results);
	return calllisp(func, args.slice(1), context, results);
}

var defaultContext = {
	'false': false,
	'true': true,
	'+': plus,
	'*': times,
	'<': lessthan,
	'>': greaterthan,
	'=': equalto,
	'-': minus,
	'/': divide,
	'if': iff,
	'lambda': lambda,
	'eval': evalf,
	'letrec': letrec,
}

function DeadResult(message) {
	this.message = message;
}

function lookup(name, context, results) {
	while (context) {
		var ctx = context[name];
		if (ctx !== undefined) {
			return ctx;
		}
		context = context.parentContext;
	}
	return new DeadResult("variable '" + name + "' not found");
}

function evallisp(el, context, results) {
	var res;
	if (el.args === undefined) {
		if (el.name === "") {
			res = "";
		} else if (el.name[0] === "'") {
			res = el.name.slice(1)
		} else if (!Number.isNaN(Number(el.name))) {
			res = Number(el.name);
		} else {
			res = lookup(el.name, context, results);
		}
	} else {
		res = lookup(el.name, context, results);
		res = calllisp(res, el.args, context, results);
	}
	results.set(el, res);
	return res;	
}

var container = document.getElementById("container");
var code = document.getElementById("code");

function makeElement() {
	var table = document.createElement("table");
	var row = document.createElement("tr");
	var head = document.createElement("td");

	row.appendChild(head);
	table.appendChild(row);

	return {table: table, head: head, row: row};
}

function elementToFunc(element, horiz) {
	var row = element.row;
	element.args = document.createElement("td");
	row.appendChild(element.args);
	element.args.classList.add("args");

	if (horiz) {
		var table = document.createElement("table");
		var row = document.createElement("tr");
		table.appendChild(row);
		element.args.appendChild(table);
		element.args = row;
	}
}

function addNextToElement(element, child, horiz) {
	var toAdd = child.table;
	if (horiz) {
		var cell = document.createElement("td");
		cell.classList.add("horiz-component");
		cell.appendChild(child.table);
		toAdd = cell;
	}
	element.args.appendChild(toAdd);
}

function draw() {
	var results = new Map([]);
	var result = evallisp(orig, defaultContext, results);
	if (result instanceof DeadResult) {
		code.innerHTML = "Error: " + result.message;
	} else {
		code.innerHTML = result + "<br><pre>" + JSON.stringify(orig, function(key, value) {if (key === "parent") {return undefined;} return value;}, " ");
	}
	container.innerHTML = "";
	var startNode = makeElement();
	drawRecursive(orig, startNode, results);
	container.appendChild(startNode.table);
}

function drawRecursive(func, el, results) {
	el.table.addEventListener("click", function(e) {
		active = func;
		selection = undefined;
		e.stopPropagation();
		draw();
	});

	el.head.innerHTML = func.name;

	if (results.get(func) instanceof DeadResult) {
		el.table.classList.add("dead-result");
	}

	if (func === active) {
		if (selection === undefined) {
			el.table.style.backgroundColor = "#aaf";			
		} else {
			el.head.innerHTML = func.name.slice(0, selection) + "<span id='cursor'></span>" + func.name.slice(selection)
		}
	}
	if (func.args) {
		var horiz = true;
		var containsActive = false;
		for (var f of func.args) {
			if (f.args !== undefined) {
				horiz = false;
			}
			if (f === active) {
				containsActive = true;
			}
		}
		horiz = (func.horiz || horiz) && !containsActive;

		elementToFunc(el, horiz);		
		for (var f of func.args) {
			var e = makeElement();
			drawRecursive(f, e, results);
			addNextToElement(el, e, horiz);
		}
	}
}

function makeFunction() {
	return {name: ""};
}

function addConnections(parent) {
	for (var element of parent.args) {
		element.parent = parent;
		if (element.args) {
			addConnections(element);
		}
	}
}

// var active = {
// 	name: "eval",
// 	args: [{
// 		name: "lambda", 
// 		args: [
// 			{name: "", args: [{name: 'x'}, {name: 'y'}, {name: 'z'}]},
// 			{name: "if", args: [{name: 'x'}, {name: 'y'}, {name: 'z'}]},
// 		]
// 	}, {name: "true"}, {name: "2"}, {name: "4"}]
// };
// var active = {
// 	name: "letrec",
// 	args: [{name: "f", args: [{
// 		name: "lambda", 
// 		args: [
// 			{name: "", args: [{name: 'x'}]},
// 			{name: "x"},
// 		]
// 	}]},
// 		{name: "f", args: [{name: "1"}]}
// 	],
// };

var active = {"name":"letrec","args":[{"name":"inc","args":[{"name":"lambda","args":[{"name":"","args":[{"name":"x"}]},{"name":"+","args":[{"name":"x"},{"name":"1"}]}]}]},{"name":"sum","args":[{"name":"lambda","args":[{"name":"","args":[{"name":"low"},{"name":"high"},{"name":"func"},{"name":"accum"}]},{"name":"if","args":[{"name":">","args":[{"name":"low"},{"name":"high"}]},{"name":"accum"},{"name":"sum", "args":[{"name":"inc","args":[{"name":"low"}]},{"name":"high"},{"name":"func"},{"name":"+","args":[{"name":"accum"},{"name":"func","args":[{"name":"low"}]}]}]}]}]}]},{"name":"sum","args":[{"name":"1"},{"name":"3"},{"name":"lambda","args":[{"name":"","args":[{"name":"x"}]},{"name":"*","args":[{"name":"x"},{"name":"x"}]}]},{"name":"0"}]}]};

addConnections(active);
var orig = active;
var selection = undefined;

function constrainSelection() {
	if (selection !== undefined) {
		if (selection > active.name.length) {
			selection = active.name.length;
		}
	}
}

window.addEventListener("keydown", function(e){
	if (e.keyCode == 37) {
		constrainSelection();
		if (selection !== undefined) {
			if (selection === 0) {
				left();
				selection = undefined;
			} else {
				selection -= 1;				
			}
		} else {
			left();
		}
        e.preventDefault();
	}
	if (e.keyCode == 38) {
		up();
        e.preventDefault();
	}
	if (e.keyCode == 39) {
		constrainSelection();
		if (selection !== undefined) {
			selection += 1;
			if (selection === active.name.length + 1) {
				selection = undefined;
				right();
			}
		} else {
			right();
		}
        e.preventDefault();
	}
	if (e.keyCode == 40) {
		down();
        e.preventDefault();
	}
	if (e.keyCode === 8) {
		// delete
        e.preventDefault();
		constrainSelection();
		if (active.name === "") {
			var parent = active.parent;
			var idx = parent.args.indexOf(active);
			active.parent.args.splice(idx, 1);
			if (active.parent.args.length === 0) {
				active = parent;
				parent.args = undefined;
			} else {
				active = parent.args[Math.max(0, idx - 1)];
			}
			selection = undefined;
		} else {
			if (selection !== undefined) {
				if (selection) {
					active.name = active.name.substring(0, selection - 1) + active.name.substring(selection);			
					selection -= 1;
				}
			} else {
				active.name = "";
			}
		}
	}
	console.log(e.keyCode);
	draw();
});

function up() {
	var p = active.parent;
	if (p) {
		var idx = p.args.indexOf(active);
		active = p.args[Math.max(idx - 1, 0)];			
	}
}
function down() {
	var p = active.parent;
	if (p) {
		var idx = p.args.indexOf(active);
		active = p.args[Math.min(idx + 1, p.args.length - 1)];
	}
}
function left() {
	if (active.parent) {
		active = active.parent;			
	}
}
function right() {
	if (active.args && active.args[0]) {
		active = active.args[0];			
	}
}

function addCellBelow() {
	var index = active.parent.args.indexOf(active);
	var newElement = makeFunction();
	newElement.parent = active.parent;
	active.parent.args.splice(index+1, 0, newElement);
	active = newElement;
	selection = undefined;
}

window.addEventListener("keypress", function(e){
	console.log(e);
	if (e.keyCode == 40) {
		// open paren
		if (active.args) {
			active = active.args[0];
		} else {
			var newElement = makeFunction();
			newElement.parent = active;
			active.args = [newElement];
			active = newElement;		
		}
		selection = undefined;
	} else if (e.keyCode == 44) {
		// ,
		addCellBelow();
	} else if (e.keyCode == 13) {
		if (selection === undefined) {
			selection = active.name.length;
		} else {
			addCellBelow();
		}
	} else if (e.keyCode == 8) {
		// delete
	} else if (e.keyCode === 27) {
		selection = undefined;
	} else if (e.key === "t" && e.ctrlKey) {
		active.horiz = !active.horiz;
	} else {
		constrainSelection();
		if (selection === undefined) {
			active.name = String.fromCharCode(e.keyCode);
			selection = 1;
		} else {
			active.name = active.name.slice(0, selection) +
			String.fromCharCode(e.keyCode) +
			active.name.slice(selection);
			selection += 1;
		}
	}
	draw();
});

draw();



// function makeSpan(text, startidx, endidx) {
// 	var span1 = document.createElement("span");
// 	var span2 = document.createElement("span");

// 	if (endidx === null) {
// 		endidx = text.length;
// 	}

// 	var a, b, c;
// 	a = text.substring(0, startidx);
// 	b = text.substring(startidx, endidx);
// 	c = text.substring(endidx, text.length);
// 	var texta = document.createTextNode(a);
// 	var textb = document.createTextNode(b);
// 	var textc = document.createTextNode(c);
// 	span1.appendChild(texta);
// 	span1.appendChild(span2);
// 	span2.appendChild(textb);
// 	span1.appendChild(textc);

// 	span2.style.backgroundColor = "red";

// 	return span1;
// }
	// if (depth === selection.depth) {
	// 	if (idx === selection.startidx && idx === selection.endidx) {
	// 		el.head.appendChild(makeSpan(func.name, selection.startchar, selection.endchar));			
	// 	} else if (idx === selection.startidx) {
	// 		childrenSelected = true;
	// 		el.head.appendChild(makeSpan(func.name, selection.startchar, null));
	// 	} else if (idx === selection.endidx) {
	// 		el.head.appendChild(makeSpan(func.name, 0, selection.endchar));
	// 	} else if (idx > selection.startidx && idx < selection.endidx) {
	// 		childrenSelected = true;
	// 		el.head.innerHTML = func.name;
	// 		el.head.style.backgroundColor = "red";			
	// 	} else {
	// 		el.head.innerHTML = func.name;
	// 	}
	// } else {
	// 	el.head.innerHTML = func.name;
	// }

</script>